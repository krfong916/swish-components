@use './variables';
@use "sass:map";
@use "sass:list";
@use "sass:math";

// compute the minimum breakpoint value and return it
@function get-min-breakpoint($size) {
  @if not(map.get(variables.$breakpoints, $size)) {
    @warn "Warning: Breakpoint value: #{$size} not defined in breakpoint map. Please specify a breakpoint size defined in the breakpoint map";
  }

  // get the minimum breakpoint for the screen size
  $min: map.get(variables.$breakpoints, $size);
  @return if($min > 0, $min, null);
}

// compute the upperbound breakpoint and return it
// put another way: given an array of numbers and a value ($size)
// return the smallest number $size is less than
@function get-max-breakpoint($size) {
  // get a list of screen size names
  $names: map.keys(variables.$breakpoints);
  // get the index for this particular screen size
  $index: list.index($names, $size);
  // using the index, determine the max breakpoint for the screen size
  // edge case: either we currently have the largest screen size and there exists no max-width
  // general case: the max-width is the nearest largest breakpoint
  $max: if(
    $index - 1 >= 1,
    list.nth(list.nth(variables.$breakpoints, $index - 1), 2) - 1,
    null
  );
  @return $max;
}

@mixin media-query_($size) {
  // based on the size of the screen, get the min and max-width breakpoint
  $minBreakpoint: get-min-breakpoint($size);
  $maxBreakpoint: get-max-breakpoint($size);

  // largest screen size
  @if ($minBreakpoint != null and $maxBreakpoint == null) {
    @media (min-width: #{$minBreakpoint}) {
      @content;
    }
    // intermediate screen size
  } @else if ($minBreakpoint != null and $maxBreakpoint != null) {
    @media (min-width: #{$minBreakpoint}) {
      @media (max-width: #{$maxBreakpoint}) {
        @content;
      }
    }
    // smallest screen size
  } @else if ($minBreakpoint == null and $maxBreakpoint != null) {
    @media (max-width: #{$maxBreakpoint}) {
      @content;
    }
    // no breakpoints for the screen size type
  } @else {
    @content;
  }
}

@mixin layout-grid($size, $margin) {
  @if (not map.has-key(variables.$columns, $size)) {
    @warn "Warning: the user-specified screen size: #{$size} is not a screen-size supported by Swish Grid. Please use a screen-size defined in the variables map";
  }

  margin: 0 auto;
  padding: $margin;
}

@mixin layout-inner($size, $gutter) {
  display: flex;
  flex-wrap: wrap;
  align-items: stretch;
  // we use a negative margin to pull the inner-layout into the grid itself
  margin: -1 * $gutter;

  @supports (display: grid) {
    display: grid;
    grid-gap: $gutter;
    grid-template-columns: repeat(
      map.get(variables.$columns, $size),
      minmax(0, 1fr)
    );
    margin: -1 * $gutter; // we use a negative margin to pull the inner-layout into the grid itself
  }
}

// @mixin make-default-col($gutter) {
//   // Set default width as a fallback
//   // this prevents columns being too narrow on small screen sizes
//   // We define flex properties on the column in make-col() later on.
//   // The flex property values will override the initial width value
//   width: 100%;
//   padding-left: $gutter;
//   padding-right: $gutter;
// }

@mixin col($size, $columns, $gutter) {
  // @include make-default-col($gutter);
  // Applies to IE10+
  // If we use the declaration flex: 1 0 0;
  // it will be a found as an error and the entire flex value will be ignored.
  // Additionally, Some CSS minifiers convert 0px to 0.
  display: block;
  flex: 1 0 0%;
  max-width: 100%;

  @supports (display: grid) {
    margin: 0;
  }
}

@mixin col-span($size, $span, $columns) {
  display: block;
  flex: 0 0 percentage($span / $columns);
  width: percentage($span / $columns);

  @supports (display: grid) {
    width: auto;
    grid-column-end: span math.min($span, map.get(variables.$columns, $size));
  }
}

@mixin col-order($order) {
  order: $order;
}

@mixin col-align($alignment) {
  @if ($alignment == "top") {
    align-self: flex-start;
  } @else if ($alignment == "middle") {
    align-self: center;
  } @else if ($alignment == "bottom") {
    align-self: flex-end;
  }
}
